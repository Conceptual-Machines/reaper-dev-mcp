import logging
import textwrap
from dataclasses import dataclass
from uuid import NAMESPACE_DNS

from docs_scraper import ReaFunc, ReaType, get_functions_from_docs, to_snake
from jinja2 import Environment, FileSystemLoader
from modules_generator import (
    AUTOGENERATED_MODULES,
    REAPER_TYPES,
    TEMPLATES_DIR,
    UNSUPPORTED_NAMESPACES,
)
from utils import get_version_from_pyproject

logger = logging.getLogger(__name__)
handler = logging.StreamHandler()
formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
handler.setFormatter(formatter)
logger.setLevel(logging.DEBUG)
logger.addHandler(handler)


ENV = Environment(loader=FileSystemLoader(TEMPLATES_DIR))
MODULE_TEMPLATE = ENV.get_template("module.jinja2")
METHOD_TEMPLATE = ENV.get_template("method.jinja2")
FUNC_CALL_TEMPLATE = ENV.get_template("function_call.jinja2")
FUNC_BODY_TEMPLATE = ENV.get_template("function_body.jinja2")
FUNC_SIGNATURE_TEMPLATE = ENV.get_template("function_signature.jinja2")
CONSTANTS_TEMPLATE = ENV.get_template("constants.jinja2")


TRACK_FX_POINTERS = ("src_fx", "fx", "idx", "fx_idx", "index")
TAKE_FX_POINTERS = ("src_fx", "fx", "idx", "fx_idx", "index")


@dataclass
class NameSpace:
    reawrap_name: str
    reascript_name: str
    pointer_type: str


def generate_function_call_args_by_name_space(
    function: ReaFunc, namespace: NameSpace
) -> list[str]:
    """Generate function call arguments for the given function by namespace."""
    reaper_args = []
    match namespace.reawrap_name:
        case "TrackFX":
            for i, arg in enumerate(function.arguments):
                if arg.reascript_type in ("MediaTrack", "MediaItemTake"):
                    if i == 0:
                        # the first argument corresponds to the attribute TrackFX.track so in the call to Reaper API
                        # we pass the pointer to the track
                        reaper_args.append("self.track.pointer")
                    else:
                        reaper_args.append(f"{arg.name}.pointer")

                elif arg.name in TRACK_FX_POINTERS:
                    if (
                        function.reawrap_name == "set_preset_by_index"
                        and arg.name == "idx"
                    ):
                        # pointer false positive, we need to pass the preset index instead
                        reaper_args.append("preset_idx")
                    else:
                        reaper_args.append("self.pointer")
                else:
                    reaper_args.append(arg.name)
        case "TakeFX":
            for i, arg in enumerate(function.arguments):
                if arg.reascript_type in ("MediaTrack", "MediaItemTake"):
                    if i == 0:
                        # the first argument corresponds to the attribute TakeFX.take so in the call to Reaper API
                        # we pass the pointer to the take
                        reaper_args.append("self.take.pointer")
                    else:
                        reaper_args.append(f"{arg.name}.pointer")
                elif arg.name in TAKE_FX_POINTERS:
                    reaper_args.append(f"self.pointer")
                else:
                    reaper_args.append(arg.name)
    return reaper_args


def generate_function_call_args(function, namespace: NameSpace):
    """Generate function call arguments for the given function."""
    reaper_args = []
    first_arg = function.arguments[0] if function.arguments else None
    if function.arguments and first_arg.is_reaper_type:
        if first_arg.reascript_type != namespace.reascript_name:
            reaper_args.append(f"self.{first_arg.name}.pointer")
        else:
            reaper_args.append("self.pointer")
        args = function.arguments[1:]
    else:
        args = function.arguments
    for i, arg in enumerate(args):
        if arg.name is None:
            reaper_args.append(f"arg_{i}")
        else:
            reaper_args.append(arg.name)
    return reaper_args


def generate_function_call(function: ReaFunc, namespace: str) -> str:
    """Generate a function call with the given function. This is the actual call to Reaper API."""
    reaper_name = function.reascript_name
    if namespace in ("TrackFX", "TakeFX"):
        # TrackFX and TakeFX arguments need to be handled differently
        reaper_args = generate_function_call_args_by_name_space(function, namespace)
    else:
        reaper_args = generate_function_call_args(function, namespace)
    tmplt = FUNC_CALL_TEMPLATE.render(reaper_name=reaper_name, reaper_args=reaper_args)
    return tmplt


def generate_signature_params_by_name_space(
    function: ReaFunc, namespace: NameSpace
) -> list[ReaType]:
    """Generate signature parameters for the given function by namespace."""
    reawrap_params = (
        []
    )  # list of parameters to be passed to the ReaWrap class function signature, excluding pointer arguments
    match namespace.reawrap_name:
        case "TrackFX":
            for i, arg in enumerate(function.arguments):
                if arg.name is None:
                    arg.name = f"arg_{i}"
                # skipping the first argument cause it corresponds to the attribute TrackFX.track
                elif i == 0 and arg.reascript_type == "MediaTrack":
                    continue
                if function.reawrap_name == "set_preset_by_index" and arg.name == "idx":
                    reawrap_params.append(
                        ReaType(
                            name="preset_idx",
                            reascript_type="number",
                            description="The index of the preset",
                        )
                    )
                # skipping any argument that corresponds to the FX index, i.e. the attribute TrackFX.pointer
                elif arg.name in TRACK_FX_POINTERS:
                    continue
                else:
                    reawrap_params.append(arg)

        case "TakeFX":
            for i, arg in enumerate(function.arguments):
                if arg.name is None:
                    arg.name = f"arg_{i}"
                # skipping the first argument cause it corresponds to the attribute TakeFX.take
                elif i == 0 and arg.reascript_type == "MediaItemTake":
                    continue
                # skipping any argument that corresponds to the FX index, i.e. the TakeFX.pointer
                elif arg.name in TAKE_FX_POINTERS:
                    continue
                else:
                    reawrap_params.append(arg)
    return reawrap_params


def generate_signature_params(function: ReaFunc) -> list[[ReaType]]:
    reawrap_params = (
        []
    )  # list of parameters to be passed to the ReaWrap class function, excluding the self pointer
    for i, arg in enumerate(function.arguments):
        # skipping the first argument cause it corresponds to the self.pointer
        if arg.is_reaper_type:
            continue
        if arg.name is None:
            arg.name = f"arg_{i}"

        reawrap_params.append(arg)
    return reawrap_params


def generate_signature(
    reawrap_name: str, reawrap_params: list[ReaType], name_space: str
) -> str:
    """Generate a function signature with the given function."""
    tmplt = FUNC_SIGNATURE_TEMPLATE.render(
        reawrap_params=reawrap_params,
        reawrap_name=reawrap_name,
        reawrap_class=name_space,
    )
    return tmplt


def generate_function_body(function: ReaFunc, function_call: str) -> str:
    """Generate a function body with the given function call.

    :param function: ReaFunc
    :param function_call: str
    """
    return_reawrap_class, return_reawrap_class_module = None, None
    optional_params = {}
    for arg in function.arguments:
        if arg.is_optional:
            optional_params[arg.name] = arg.default_value
    return_values = []
    for i, rv in enumerate(function.return_values, start=1):
        if rv.is_reaper_type:
            return_reawrap_class = rv.reawrap_type
            return_reawrap_class_module = to_snake(rv.reawrap_type)
        if rv.name:
            return_values.append(rv.name)
        else:
            return_values.append(f"return_{i}")
    return FUNC_BODY_TEMPLATE.render(
        optional_params=optional_params,
        return_values=return_values,
        function_call=function_call,
        return_reawrap_class=return_reawrap_class,
        return_reawrap_class_module=return_reawrap_class_module,
    )


def generate_method(name_space: NameSpace, function: ReaFunc) -> str:
    """Generate a method with the given name and function."""
    if name_space.reawrap_name in ("TrackFX", "TakeFX"):
        reawrap_params = generate_signature_params_by_name_space(function, name_space)
    else:
        reawrap_params = generate_signature_params(function)
    function_signature = generate_signature(
        function.reawrap_name, reawrap_params, name_space.reawrap_name
    )
    function_call = generate_function_call(function, name_space)
    function_body = generate_function_body(function, function_call)
    return_values = generate_return_values(function)

    function_name = " ".join(function.reawrap_name.split("_")).title()
    tmplt = METHOD_TEMPLATE.render(
        function_name=function_name,
        reascript_name=function.reascript_name,
        docs=textwrap.fill(function.docs, width=80) if function.docs else "",
        params=reawrap_params,
        return_values=return_values,
        function_signature=function_signature,
        function_body=function_body,
    )
    return tmplt


def generate_return_values(function) -> list[ReaType]:
    """Generate return values for the given function."""
    return_values = []
    for i, rv in enumerate(function.return_values, start=1):
        if rv.name == "ret_val":
            # this is a boolean that indicates if the function was successful
            continue
        return_values.append(rv)
    return return_values


def generate_constants(name: str, reawrap_name: str, constants: list[ReaType]) -> str:
    """Generate a constants table with the given constants."""
    return CONSTANTS_TEMPLATE.render(
        name=name, reawrap_name=reawrap_name, constants=constants
    )


def generate_constructor_args(name_space: NameSpace) -> list[ReaType]:
    """Generate constructor arguments for the given name_space / module."""
    constructor_args = {}
    match name_space.reawrap_name:
        case "Project":
            return [
                ReaType(
                    name="project_idx",
                    reascript_type="number",
                    description="The index of the project",
                    is_optional=True,
                    is_pointer=True,
                )
            ]
        case "Track":
            return [
                ReaType(
                    name="track",
                    reascript_type="userdata",
                    description="The pointer to Reaper MediaTrack*",
                    is_pointer=True,
                )
            ]
        case "Item":
            return [
                ReaType(
                    name="item",
                    reascript_type="userdata",
                    description="The pointer to Reaper MediaItem*",
                    is_pointer=True,
                )
            ]
        case "Take":
            return [
                ReaType(
                    name="take",
                    reascript_type="userdata",
                    description="The pointer to Reaper MediaItem_Take*",
                    is_pointer=True,
                )
            ]
        case "Envelope":
            return [
                ReaType(
                    name="envelope",
                    reascript_type="userdata",
                    description="The pointer to Reaper TrackEnvelope*",
                    is_pointer=True,
                )
            ]
        case "TrackFX":
            return [
                ReaType(
                    name="track",
                    reascript_type="MediaTrack",
                    description="The MediaTrack object",
                ),
                ReaType(
                    name="fx_idx",
                    reascript_type="number",
                    description="The index of the FX",
                    is_pointer=True,
                ),
            ]
        case "TakeFX":
            return [
                ReaType(
                    name="take",
                    reascript_type="MediaItemTake",
                    description="The MediaItemTake object",
                ),
                ReaType(
                    name="fx_idx",
                    reascript_type="number",
                    description="The index of the FX",
                    is_pointer=True,
                ),
            ]
        case "PCM":
            return [
                ReaType(
                    name="source",
                    reascript_type="userdata",
                    description="The pointer to PCM_source*",
                    is_pointer=True,
                )
            ]
        case "AudioAccessor":
            return [
                ReaType(
                    name="audio_accessor",
                    reascript_type="userdata",
                    description="The pointer to audio accessor",
                    is_pointer=True,
                )
            ]
    return constructor_args


def get_dependencies(name_space: str, functions: list[ReaFunc]) -> list[str]:
    """Get dependencies for the given name_space."""
    dependencies = {"helpers"}
    for function in functions:
        for arg in function.arguments:
            if name_space == "PCM" and arg.reascript_type == "PCM_source":
                continue
            if arg.reascript_type == "PCM_source" and name_space != "PCM":
                dependencies.add("pcm")
            elif arg.is_reaper_type and arg.reascript_type != name_space:
                dependencies.add(to_snake(arg.reascript_type))
    return list(sorted(dependencies))


def generate_module(name_space: NameSpace, functions: list[ReaFunc]) -> str:
    """Generate a module with the given name and functions.
    Some modules have been renamed from the original name space for convenience.

    :param name_space: str The name_space of the module.
    :param functions: list[ReaFunc]
    """
    methods = []
    for function in functions:
        if function.constants:
            constant_name = (
                f"{name_space.reawrap_name}."
                + "".join([p.title() for p in function.reawrap_name.split("_")])
                + "Constants"
            )
            reawrap_name = f"{name_space.reawrap_name}:{function.reawrap_name}"
            constants = generate_constants(
                constant_name, reawrap_name, function.constants
            )
            methods.append(constants)
            for arg in function.arguments:
                # the first string argument is mapped to constants
                if arg.reascript_type == "string":
                    arg.description = constant_name
                    break
            method = generate_method(name_space, function)
            methods.append(method)
        else:
            method = generate_method(name_space, function)
            methods.append(method)
    dependencies = get_dependencies(name_space, functions)
    pointer_type = name_space.pointer_type
    description = f"Provide implementation for {name_space.reawrap_name} functions"
    constructor_args = generate_constructor_args(name_space)
    module_name = to_snake(name_space.reawrap_name)
    pversion = get_version_from_pyproject()
    has_optional_args = any(arg.is_optional for arg in constructor_args)
    tmplt = MODULE_TEMPLATE.render(
        version=pversion,
        dependencies=dependencies,
        class_name=name_space.reawrap_name,
        module_name=module_name,
        pointer_type=pointer_type,
        description=description,
        constructor_args=constructor_args,
        methods=methods,
        has_optional_args=has_optional_args,
    )
    with open(AUTOGENERATED_MODULES / f"{module_name}.lua", "w") as f:
        f.write(tmplt)
    logger.info(f"Generated module: {module_name}.lua")


NAMESPACE_RENAMES = {
    "ReaProject": "Project",
    "MediaItem": "Item",
    "MediaItemTake": "Take",
    "MediaTrack": "Track",
    "TrackEnvelope": "Envelope",
}

NAMESPACE_POINTER_TYPES = {
    "Project": "ReaProject*",
    "Track": "MediaTrack*",
    "Item": "MediaItem*",
    "Take": "MediaItemTake*",
    "Envelope": "TrackEnvelope*",
    "PCM": "PCM_source*",
    "AudioAccessor": "AudioAccessor*",
}


def main():
    AUTOGENERATED_MODULES.mkdir(exist_ok=True)
    functions = get_functions_from_docs()
    for name_space_str, functions in functions.items():
        if name_space_str in UNSUPPORTED_NAMESPACES:
            logger.info(
                f"Skipping unsupported namespace: {name_space_str}",
            )
            continue
        renamed_ns = NAMESPACE_RENAMES.get(name_space_str, name_space_str)
        pointer_type = NAMESPACE_POINTER_TYPES.get(renamed_ns, renamed_ns)
        name_space = NameSpace(
            reawrap_name=renamed_ns,
            reascript_name=name_space_str,
            pointer_type=pointer_type,
        )
        generate_module(name_space, functions)


if __name__ == "__main__":
    main()
